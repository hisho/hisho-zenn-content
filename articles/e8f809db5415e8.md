---
title: "zodã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ—¥æœ¬èªåŒ–ã¨ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º"
emoji: "ğŸŒ"
type: "tech"
topics: ["zod","i18n","typescript"]
published: false
---
zodã«å…¥é–€ã—ã¾ã—ãŸã€‚   
å‹ç”Ÿæˆã§ããŸã‚Šã€`preprocess`ã¨ã‹ä¾¿åˆ©ã§ã™ã­ğŸ˜
zodã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹æ—¥æœ¬èªã®è¨˜äº‹ãŒãªã‹ã£ãŸã®ã§è‰²ã€…èª¿ã¹ã¦ã¿ãŸ   
ã¤ã„ã§ã«Next.jsã®i18nã¨é€£æºã—ã¦ã¿ãŸ

## ãƒªãƒã‚¸ãƒˆãƒª
https://github.com/hisho/nextjs-with-zod-i18n

## ãƒ‡ãƒ¢
ãƒ‡ãƒ¢ã§ã¯chakraã¨react-hook-formã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚
@[codesandbox](https://codesandbox.io/embed/sweet-sea-gecs81?fontsize=14&hidenavigation=1&theme=dark)
https://nextjs-with-zod-i18n-demo.vercel.app/

## ã‚ªãƒªã‚¸ãƒŠãƒ«ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
```tsx:å…¬å¼ã‚ˆã‚Š
// optional custom error message
z.string().nonempty({ message: "Can't be empty" });
```
ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®keyã‚’messageã«ã—ã¦valueã‚’å¥½ããªå€¤ã«ã™ã‚Œã°ã„ã‘ã‚‹ã‚“ã§ã™ã­ğŸ¥°

## ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
zodã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã™ã¹ã¦è‹±èªã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™   
`Required`(å¿…é ˆ)ãªã©ã¯ã©ã“ã§ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º(æ—¥æœ¬èªåŒ–)ã™ã‚‹ã®ã ã‚ã†ğŸ¤”

å…¬å¼ã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚’èª­ã¨ãƒ»ãƒ»ãƒ»
https://github.com/colinhacks/zod/blob/master/ERROR_HANDLING.md#customizing-errors-with-zoderrormap

```tsx:å…¬å¼ã‚ˆã‚Š
import { z } from "zod";

const customErrorMap: z.ZodErrorMap = (issue, ctx) => {
  if (issue.code === z.ZodIssueCode.invalid_type) {
    if (issue.expected === "string") {
      return { message: "bad type!" };
    }
  }
  if (issue.code === z.ZodIssueCode.custom) {
    return { message: `less-than-${(issue.params || {}).minimum}` };
  }
  return { message: ctx.defaultError };
};

z.setErrorMap(customErrorMap);
```
<br><br><br>
ã»ãƒ¼ã‚“<br><br><br><br>
ãƒ»ãƒ»ãƒ»<br><br><br><br>
ãƒ»ãƒ»ãƒ»<br><br><br><br>

Requiredã¯ã©ã“ã‹ã‚‰å¤‰ãˆã‚‹ã®ã ï¼ŸğŸ¥²

ã‚ã‹ã‚‰ãªã„ã®ã§ã€`Required`ã‚’githubã‹ã‚‰æ¢ã—ãŸã‚‰è©²å½“ã®ç®‡æ‰€ã‚’è¦‹ã¤ã‘ãŸ
https://github.com/colinhacks/zod/blob/cbbfedd15ffbe7d880f52d6becb76dcaef54875f/src/ZodError.ts#L284

ã¤ã¾ã‚Šã€ã“ã®switchã§æ›¸ã‹ã‚Œã¦ã„ã‚‹éƒ¨åˆ†ã‚’ä¸Šã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã¨ã„ã„æ„Ÿã˜ã«ã™ã‚Œã°è‰¯ã„ã‚ã‘ã§ã‚ã‚‹ğŸ˜
```tsx
  switch (issue.code) {
  case ZodIssueCode.invalid_type:
    if (issue.received === "undefined") {
      message = "Required";
    } else {
      message = `Expected ${issue.expected}, received ${issue.received}`;
    }
    break;
  case ZodIssueCode.unrecognized_keys:
    message = `Unrecognized key(s) in object: ${issue.keys
      .map((k) => `'${k}'`)
      .join(", ")}`;
    break;
  case ZodIssueCode.invalid_union:
    message = `Invalid input`;
    break;
  case ZodIssueCode.invalid_union_discriminator:
    message = `Invalid discriminator value. Expected ${issue.options
      .map((val) => (typeof val === "string" ? `'${val}'` : val))
      .join(" | ")}`;
    break;
  case ZodIssueCode.invalid_enum_value:
    message = `Invalid enum value. Expected ${issue.options
      .map((val) => (typeof val === "string" ? `'${val}'` : val))
      .join(" | ")}`;
    break;
  case ZodIssueCode.invalid_arguments:
    message = `Invalid function arguments`;
    break;
  case ZodIssueCode.invalid_return_type:
    message = `Invalid function return type`;
    break;
  case ZodIssueCode.invalid_date:
    message = `Invalid date`;
    break;
  case ZodIssueCode.invalid_string:
    if (issue.validation !== "regex") message = `Invalid ${issue.validation}`;
    else message = "Invalid";
    break;
  case ZodIssueCode.too_small:
    if (issue.type === "array")
      message = `Array must contain ${
        issue.inclusive ? `at least` : `more than`
      } ${issue.minimum} element(s)`;
    else if (issue.type === "string")
      message = `String must contain ${
        issue.inclusive ? `at least` : `over`
      } ${issue.minimum} character(s)`;
    else if (issue.type === "number")
      message = `Number must be greater than ${
        issue.inclusive ? `or equal to ` : ``
      }${issue.minimum}`;
    else message = "Invalid input";
    break;
  case ZodIssueCode.too_big:
    if (issue.type === "array")
      message = `Array must contain ${
        issue.inclusive ? `at most` : `less than`
      } ${issue.maximum} element(s)`;
    else if (issue.type === "string")
      message = `String must contain ${
        issue.inclusive ? `at most` : `under`
      } ${issue.maximum} character(s)`;
    else if (issue.type === "number")
      message = `Number must be less than ${
        issue.inclusive ? `or equal to ` : ``
      }${issue.maximum}`;
    else message = "Invalid input";
    break;
  case ZodIssueCode.custom:
    message = `Invalid input`;
    break;
  case ZodIssueCode.invalid_intersection_types:
    message = `Intersection results could not be merged`;
    break;
  case ZodIssueCode.not_multiple_of:
    message = `Number must be a multiple of ${issue.multipleOf}`;
    break;
  default:
    message = _ctx.defaultError;
    util.assertNever(issue);
}
```

## `message = "XXXX"`ã‚’`return { message: XXXX }`ã®å½¢å¼ã«æ›¸ãæ›ãˆã‚‹

```diff:tsx
switch (issue.code) {
  case ZodIssueCode.invalid_type:
    if (issue.received === "undefined") {
-      message = "Required";
+      return {
+        message: 'å¿…é ˆ'
+       }
    } else {
-      message = `Expected ${issue.expected}, received ${issue.received}`;
+      return {
+        message: `Expected ${issue.expected}, received ${issue.received}`,
+      }
    }
-    break;
}
```

## `default`ã‚’`{ message: ctx.defaultError }`ã¨ã—ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™ã‚ˆã†ã«å¤‰æ›´ã™ã‚‹

```diff:tsx
switch (issue.code) {
  default:
-    message = _ctx.defaultError;
-    util.assertNever(issue);
+    return { message: ctx.defaultError }
}
```


```tsx
export const zodCustomErrorMap = (issue, ctx): z.ZodErrorMap => {
    switch (issue.code) {
      case z.ZodIssueCode.invalid_type:
        if (issue.received === 'undefined') {
          return {
            message: 'å¿…é ˆ'
          }
        } else {
          return {
            message: `Expected ${issue.expected}, received ${issue.received}`,
          }
        }
      case z.ZodIssueCode.unrecognized_keys:
        return {
          message: `Unrecognized key(s) in object: ${issue.keys
            .map((k) => `'${k}'`)
            .join(', ')}`,
        }
      case z.ZodIssueCode.invalid_union:
        return {
          message: `Invalid input`,
        }
      case z.ZodIssueCode.invalid_union_discriminator:
        return {
          message: `Invalid discriminator value. Expected ${issue.options
            .map((val) => (typeof val === 'string' ? `'${val}'` : val))
            .join(' | ')}`,
        }
      case z.ZodIssueCode.invalid_enum_value:
        return {
          message: `Invalid enum value. Expected ${issue.options
            .map((val) => (typeof val === 'string' ? `'${val}'` : val))
            .join(' | ')}`,
        }
      case z.ZodIssueCode.invalid_arguments:
        return {
          message: `Invalid function arguments`,
        }
      case z.ZodIssueCode.invalid_return_type:
        return {
          message: `Invalid function return type`,
        }
      case z.ZodIssueCode.invalid_date:
        return {
          message: `Invalid date`,
        }
      case z.ZodIssueCode.invalid_string:
        if (issue.validation !== 'regex') {
          return {
            message: isJapanese
              ? `${issue.validation}ã¯ç„¡åŠ¹ãªå½¢å¼ã§ã™`
              : ctx.defaultError,
          }
        } else {
          return {
            message: 'Invalid',
          }
        }
      case z.ZodIssueCode.too_small:
        if (issue.type === 'array') {
          return {
            message: `Array must contain ${
              issue.inclusive ? `at least` : `more than`
            } ${issue.minimum} element(s)`,
          }
        } else if (issue.type === 'string') {
          return {
            message: isJapanese
              ? issue.inclusive
                ? `æ–‡å­—åˆ—ã«ã¯å°‘ãªãã¨ã‚‚${issue.minimum}æ–‡å­—ãŒå«ã¾ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`
                : `æ–‡å­—åˆ—ã«ã¯${issue.minimum}æ–‡å­—ä»¥ä¸ŠãŒå«ã¾ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`
              : ctx.defaultError,
          }
        } else if (issue.type === 'number') {
          return {
            message: `Number must be greater than ${
              issue.inclusive ? `or equal to ` : ``
            }${issue.minimum}`,
          }
        } else {
          return { message: 'Invalid input' }
        }
      case z.ZodIssueCode.too_big:
        if (issue.type === 'array') {
          return {
            message: `Array must contain ${
              issue.inclusive ? `at most` : `less than`
            } ${issue.maximum} element(s)`,
          }
        } else if (issue.type === 'string') {
          return {
            message: `String must contain ${
              issue.inclusive ? `at most` : `under`
            } ${issue.maximum} character(s)`,
          }
        } else if (issue.type === 'number') {
          return {
            message: `Number must be less than ${
              issue.inclusive ? `or equal to ` : ``
            }${issue.maximum}`,
          }
        } else {
          return {
            message: 'Invalid input',
          }
        }
      case z.ZodIssueCode.custom:
        return {
          message: `Invalid input`,
        }
      case z.ZodIssueCode.invalid_intersection_types:
        return {
          message: `Intersection results could not be merged`,
        }
      case z.ZodIssueCode.not_multiple_of:
        return {
          message: `Number must be a multiple of ${issue.multipleOf}`,
        }
      default:
        return { message: ctx.defaultError }
    }
  }

z.setErrorMap(zodCustomErrorMap())
```
ã®ã“ã‚Šã¯ã„ã„æ„Ÿã˜ã«ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã—ã¦ã¿ã¦ãã ã•ã„ğŸ˜€

## Nextã¨é€£æºã™ã‚‹

```tsx:ZodErrorMap.tsx

import { ReactElement } from 'react'
import { z } from 'zod'
import { zodCustomErrorMap } from '@src/libs/validation/zodCustomErrorMap'

type ZodErrorMapProps = Required<{
  children: ReactElement
}>

/**
 * @see https://github.com/colinhacks/zod/blob/master/ERROR_HANDLING.md#global-error-map
 * @see https://github.com/colinhacks/zod/blob/cbbfedd15ffbe7d880f52d6becb76dcaef54875f/src/ZodError.ts#L284
 */
export const ZodErrorMap = ({ children }: ZodErrorMapProps) => {
  z.setErrorMap(zodCustomErrorMap())

  return <>{children}</>
}
```

```tsx:_app.tsx
import type { AppProps } from 'next/app'
import { ZodErrorMap } from '@src/libs/validation/ZodErrorMap'

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <ZodErrorMap>
      <Component {...pageProps} />
    </ZodErrorMap>
  )
}

export default MyApp
```

## ã¤ã„ã§ã«i18nå¯¾å¿œã™ã‚‹

### next.jsã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®i18nã®è¨­å®šã‚’ã™ã‚‹
```js:next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  /**
   * @see https://nextjs.org/docs/advanced-features/i18n-routing
   * @see https://zenn.dev/steelydylan/articles/nextjs-with-i18n
   */
  i18n: {
    locales: ['en', 'ja'],
    defaultLocale: 'ja',
  },
}

module.exports = nextConfig
```

### localeã‚’åˆ¤å®šã™ã‚‹hooksã‚’ä½œã‚‹

```ts:useLocale.ts
import { NextRouter, useRouter } from 'next/router'

const localeMap = (locale: NextRouter['locale']) => {
  switch (locale) {
    case 'ja':
      return 'ja'
    case 'en':
      return 'en'
    default:
      return 'ja'
  }
}

export const useLocale = (): {
  isEnglish: boolean
  isJapanese: boolean
  locale: ReturnType<typeof localeMap>
} => {
  const { locale: _locale } = useRouter()

  const locale = localeMap(_locale)
  const isJapanese = locale === 'ja'
  const isEnglish = locale === 'en'
  return {
    isEnglish,
    isJapanese,
    locale,
  }
}

export type UseLocaleResult = ReturnType<typeof useLocale>
```

### zodCustomErrorMapã«localeã‚’å—ã‘å–ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹

```tsx:zodCustomErrorMap.ts 
import { z } from 'zod'
import type { UseLocaleResult } from '@src/hooks/useLocale'

export const zodCustomErrorMap =
  (locale: UseLocaleResult['locale']): z.ZodErrorMap =>
  (issue, ctx) => {
    const isJapanese = locale === 'ja'
    /**
     * enã®å ´åˆã¯Defaultã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’è¿”ã™
     */
    if (locale === 'en') {
      return { message: ctx.defaultError }
    }
    switch (issue.code) {
      case z.ZodIssueCode.invalid_type:
        if (issue.received === 'undefined') {
          return {
            /**
              * ãªã‚“ã¨ãªãisJapaneseã®åˆ†å²ã‚’æ›¸ã„ã¦ã„ã‚‹
              */
            message: isJapanese ? 'å¿…é ˆ' : ctx.defaultError,
          }
        } else {
          return {
            message: `Expected ${issue.expected}, received ${issue.received}`,
          }
        }
      case z.ZodIssueCode.unrecognized_keys:
        return {
          message: `Unrecognized key(s) in object: ${issue.keys
            .map((k) => `'${k}'`)
            .join(', ')}`,
        }
      case z.ZodIssueCode.invalid_union:
        return {
          message: `Invalid input`,
        }
      case z.ZodIssueCode.invalid_union_discriminator:
        return {
          message: `Invalid discriminator value. Expected ${issue.options
            .map((val) => (typeof val === 'string' ? `'${val}'` : val))
            .join(' | ')}`,
        }
      case z.ZodIssueCode.invalid_enum_value:
        return {
          message: `Invalid enum value. Expected ${issue.options
            .map((val) => (typeof val === 'string' ? `'${val}'` : val))
            .join(' | ')}`,
        }
      case z.ZodIssueCode.invalid_arguments:
        return {
          message: `Invalid function arguments`,
        }
      case z.ZodIssueCode.invalid_return_type:
        return {
          message: `Invalid function return type`,
        }
      case z.ZodIssueCode.invalid_date:
        return {
          message: `Invalid date`,
        }
      case z.ZodIssueCode.invalid_string:
        if (issue.validation !== 'regex') {
          return {
            message: isJapanese
              ? `${issue.validation}ã¯ç„¡åŠ¹ãªå½¢å¼ã§ã™`
              : ctx.defaultError,
          }
        } else {
          return {
            message: 'Invalid',
          }
        }
      case z.ZodIssueCode.too_small:
        if (issue.type === 'array') {
          return {
            message: `Array must contain ${
              issue.inclusive ? `at least` : `more than`
            } ${issue.minimum} element(s)`,
          }
        } else if (issue.type === 'string') {
          return {
            message: isJapanese
              ? issue.inclusive
                ? `æ–‡å­—åˆ—ã«ã¯å°‘ãªãã¨ã‚‚${issue.minimum}æ–‡å­—ãŒå«ã¾ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`
                : `æ–‡å­—åˆ—ã«ã¯${issue.minimum}æ–‡å­—ä»¥ä¸ŠãŒå«ã¾ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`
              : ctx.defaultError,
          }
        } else if (issue.type === 'number') {
          return {
            message: `Number must be greater than ${
              issue.inclusive ? `or equal to ` : ``
            }${issue.minimum}`,
          }
        } else {
          return { message: 'Invalid input' }
        }
      case z.ZodIssueCode.too_big:
        if (issue.type === 'array') {
          return {
            message: `Array must contain ${
              issue.inclusive ? `at most` : `less than`
            } ${issue.maximum} element(s)`,
          }
        } else if (issue.type === 'string') {
          return {
            message: `String must contain ${
              issue.inclusive ? `at most` : `under`
            } ${issue.maximum} character(s)`,
          }
        } else if (issue.type === 'number') {
          return {
            message: `Number must be less than ${
              issue.inclusive ? `or equal to ` : ``
            }${issue.maximum}`,
          }
        } else {
          return {
            message: 'Invalid input',
          }
        }
      case z.ZodIssueCode.custom:
        return {
          message: `Invalid input`,
        }
      case z.ZodIssueCode.invalid_intersection_types:
        return {
          message: `Intersection results could not be merged`,
        }
      case z.ZodIssueCode.not_multiple_of:
        return {
          message: `Number must be a multiple of ${issue.multipleOf}`,
        }
      default:
        return { message: ctx.defaultError }
    }
  }
```

## localeã«ã‚ˆã£ã¦zodã®setErrorMapã®å€¤ã‚’å¤‰ãˆã‚‹providerã‚’ä½œã‚‹

```tsx:ZodErrorMap.tsx
import { ReactElement } from 'react'
import { useLocale } from '@src/hooks/useLocale'
import { z } from 'zod'
import { zodCustomErrorMap } from '@src/libs/validation/zodCustomErrorMap'

type ZodErrorMapProps = Required<{
  children: ReactElement
}>

/**
 * @see https://github.com/colinhacks/zod/blob/master/ERROR_HANDLING.md#global-error-map
 * @see https://github.com/colinhacks/zod/blob/cbbfedd15ffbe7d880f52d6becb76dcaef54875f/src/ZodError.ts#L284
 */
export const ZodErrorMap = ({ children }: ZodErrorMapProps) => {
  const { locale } = useLocale()
  z.setErrorMap(zodCustomErrorMap(locale))

  return <>{children}</>
}
```

### _app.tsxã«èª­ã¿è¾¼ã¾ã›ã‚‹
```tsx:_app.tsx
import type { AppProps } from 'next/app'
import { ZodErrorMap } from '@src/libs/validation/ZodErrorMap'

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <ZodErrorMap>
      <Component {...pageProps} />
    </ZodErrorMap>
  )
}

export default MyApp
```

## ã¾ã¨ã‚
ã ã‚Œã‹å…¨éƒ¨ç¿»è¨³ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ä½œã£ã¦ãã‚ŒğŸ˜‚


ä»Šå›ä½¿ã£ãŸãƒªãƒã‚¸ãƒˆãƒª
https://github.com/hisho/nextjs-with-zod-i18n